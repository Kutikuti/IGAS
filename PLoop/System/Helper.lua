-- Author      : Kurapica
-- Create Date : 2014/09/11
-- ChangeLog   :

_ENV = Module "System.Helper" "0.1.0"

namespace "System"

CACHE_TABLE = setmetatable({}, {
	__call = function(self, key)
		if key then
			tinsert(self, wipe(key))
		else
			return tremove(self) or {}
		end
	end,
})

__Doc__[[Used to show help for other features]]
__Final__()
__NonInheritable__()
interface "Helper" (function(_ENV)
	import "System.Reflector"
	import "System.XML"

	--------------------------------------
	--- Method
	--------------------------------------
	doc "Help" [[
		<desc>Return help information of the target</desc>
		<param name="owner">the target's owner</param>
		<param name="name" optional="true">the query name, default the owner's name</param>
		<param name="targetType" optional="true" type="System.AttributeTargets">the query target type, can be auto-generated by the name</param>
		<return type="string">the detail information of the target</return>
	]]

	-- The cache for constructor parameters
	local function buildSubNamespace(ns, rs)
		local _Enums = CACHE_TABLE()
		local _Structs = CACHE_TABLE()
		local _Classes = CACHE_TABLE()
		local _Interfaces = CACHE_TABLE()
		local _Namespaces = CACHE_TABLE()

		local subNS = GetSubNamespace(ns)

		if subNS and next(subNS) then
			for _, sns in ipairs(subNS) do
				sns = ns[sns]

				if IsEnum(sns) then
					tinsert(_Enums, sns)
				elseif IsStruct(sns) then
					tinsert(_Structs, sns)
				elseif IsInterface(sns) then
					tinsert(_Interfaces, sns)
				elseif IsClass(sns) then
					tinsert(_Classes, sns)
				else
					tinsert(_Namespaces, sns)
				end
			end

			if next(_Enums) then
				tinsert(rs, "\n Sub Enum :")

				for _, sns in ipairs(_Enums) do tinsert(rs, "    " .. GetNameSpaceName(sns)) end
			end

			if next(_Structs) then
				tinsert(rs, "\n Sub Struct :")

				for _, sns in ipairs(_Structs) do tinsert(rs, "    " .. GetNameSpaceName(sns)) end
			end

			if next(_Interfaces) then
				tinsert(rs, "\n Sub Interface :")

				for _, sns in ipairs(_Interfaces) do tinsert(rs, "    " .. GetNameSpaceName(sns)) end
			end

			if next(_Classes) then
				tinsert(rs, "\n Sub Class :")

				for _, sns in ipairs(_Classes) do tinsert(rs, "    " .. GetNameSpaceName(sns)) end
			end

			if next(_Namespaces) then
				tinsert(rs, "\n Sub NameSpace :")

				for _, sns in ipairs(_Namespaces) do tinsert(rs, "    " .. GetNameSpaceName(sns)) end
			end
		end

		CACHE_TABLE(_Enums)
		CACHE_TABLE(_Structs)
		CACHE_TABLE(_Classes)
		CACHE_TABLE(_Interfaces)
		CACHE_TABLE(_Namespaces)
	end

	local function getDocumentPart(doc, part)
		if doc:match("^%s*<") then
			-- parse as xml
			return doc:gmatch("<" .. part .. ".->.-</" .. part .. ">")
		else
			-- only description
			if part == "desc" or "description" then return doc end
		end
	end

	local function getDescription(ns, name, targetType)
		local doc = GetDocument(ns, name, targetType)

		if doc then
			doc = getDocumentPart(doc, "desc") or getDocumentPart(doc, "description")

			if type(doc) == "function" then doc = doc() end

			return doc
		end
	end

	local function parseOptions(opt)
		if type(opt) ~= "string" then return end

		local ret = CACHE_TABLE()

		pcall(setfenv(loadstring(opt:gsub("<%w+%s+(.-)>(.-)</%w+>", "%1 desc=[[%2]]")), ret))

		return ret
	end

	function Help(ns, name, targetType)
		if type(ns) == "string" then ns = GetNameSpaceForName(ns) end

		if not IsNameSpace(ns) then return "" end

		local rs = CACHE_TABLE()

		if not name or name == GetNameSpaceName(ns) then
			-- Scan attributes
			if IsFinal(ns) then tinsert(rs, "[__Final__]") end
			if IsFlagsEnum(ns) then tinsert(rs, "[__Flags__]") end
			if IsNonInheritable(ns) then tinsert(rs, "[__NonInheritable__]") end
			if IsNonExpandable(ns) then tinsert(rs, "[__NonExpandable__]") end
			if IsAutoCache(ns) then tinsert(rs, "[__Cache__]") end
			if IsUniqueClass(ns) then tinsert(rs, "[__Unique__]") end
			if IsChildClass(__Attribute__, ns) then
				local usage = __Attribute__._GetClassAttribute(ns, __AttributeUsage__)

				if usage then
					tinsert(rs,
						"[__AttributeUsage__{ " ..
						"AttributeTarget = " .. Serialize(usage.AttributeTarget, AttributeTargets) .. ", " ..
						"Inherited = " .. tostring(usage.Inherited and true or false) .. ", " ..
						"AllowMultiple = " .. tostring(usage.AllowMultiple and true or false) .. ", " ..
						"RunOnce = " .. tostring(usage.RunOnce and true or false) ..
						" }]")
				end
			end

			tinsert(rs, "[" .. (GetNameSpaceType(ns) or TYPE_NAMESPACE) .. "] " .. GetNameSpaceFullName(ns) .. " :")

			-- Scan document
			local doc = getDescription(ns)

			if type(doc) == "string" then
				tinsert(rs, "  Description :")
				tinsert(rs, "    " .. doc:gsub("[\n\r]", "%1    "))
			end

			-- Special settings
			if IsEnum(ns) then
				-- Scan enum values
				tinsert("  Enumeration :")
				for _, enums in ipairs(GetEnums(ns)) do
					local value = ns[enums]

					if type(value) == "string" then
						value = ("%q"):format(value)
					else
						value = tostring(value)
					end

					tinsert(rs, "    " .. enums .. " = " .. value)
				end
			elseif IsStruct(ns) then
				-- Scan parts
				if stype == _STRUCT_TYPE_MEMBER or stype == _STRUCT_TYPE_CUSTOM then
					local parts = GetStructParts(ns)

					if parts and next(parts) then
						tinsert(rs, "\n  Field :")

						for _, name in ipairs(parts) do
							tinsert(rs, "    " .. name .. " = " .. tostring(info.StructEnv[name]))
						end
					end
				elseif stype == _STRUCT_TYPE_ARRAY then
					local ele = GetStructArrayElement(ns)

					if ele then
						tinsert(rs, "\n  Element :\n    " .. tostring(ele))
					end
				end
			elseif IsClass(ns) or IsInterface(ns) then
				-- Scan super class
				local super = GetSuperClass(ns)
				if super then
					tinsert(rs, "\n  Super Class :\n    " .. GetNameSpaceFullName(super))
				end

				-- Scan extend interfaces
				local extends = GetExtendInterfaces(ns)
				if extends and next(extends) then
					tinsert(rs, "\n  Extend Interface :")
					for _, IF in ipairs(extends) do
						tinsert(rs, "    " .. GetNameSpaceFullName(IF))
					end
				end
			end

			-- Scan SubNameSpace
			buildSubNamespace(ns, rs)

			-- Scan events
			local evts = GetEvents(ns)

			if evts and next(evts) then
				tinsert(rs, "  Event :")

				for _, name in ipairs(evts) do
					local desc = getDescription(ns, name, AttributeTargets.Event)

					if desc then
						tinsert(rs, "    " .. name .. " - " .. desc)
					else
						tinsert(rs, "    " .. name)
					end
				end
			end

			-- Scan require or optional features
			local opt = getDocumentPart(GetDocument(ns), "optional")
			local req = getDocumentPart(GetDocument(ns), "require")

			local opts = CACHE_TABLE()
			local reqs = CACHE_TABLE()

			if opt then local v = parseOptions(opt()) while v do opts[v.name] = v; v = parseOptions(opt()) end end
			if req then local v = parseOptions(req()) while v do reqs[v.name] = v; v = parseOptions(req()) end end

			-- Scan methods
			local methods = GetMethods(ns)
			local hasMethodHeader = false

			if methods and next(methods) then
				tinsert(rs, "  Method :")
				hasMethodHeader = true

				for _, name in ipairs(methods) do
					local desc = getDescription(ns, name, AttributeTargets.Method)
					local isOptional = IsOptionalMethod(ns, name)
					local isRequire = IsRequiredMethod(ns, name)

					if opts[name] then isOptional = true; desc = desc or opts[name].desc end
					if reqs[name] then isRequire = true; desc = desc or reqs[name].desc end

					tinsert(rs, "    " .. (isOptional and "[__Optional__]" or "") ..
											(isRequire and "[__Require__]" or "") ..
											name ..
											(desc and (" - " .. desc) or ""))

					if opts[name] then CACHE_TABLE(opts[name]); opts[name] = nil end
					if reqs[name] then CACHE_TABLE(reqs[name]); reqs[name] = nil end
				end
			end

			for name, req in pairs(reqs) do
				if req.type == "method" then
					if not hasMethodHeader then
						tinsert(rs, "  Method :")
						hasMethodHeader = true
					end

					tinsert(rs, "    [__Require__]" .. name .. (req.desc and (" - " .. req.desc) or ""))

					reqs[name] = nil

					CACHE_TABLE(req)
				end
			end

			for name, opt in pairs(opts) do
				if opt.type == "method" then
					if not hasMethodHeader then
						tinsert(rs, "  Method :")
						hasMethodHeader = true
					end

					tinsert(rs, "    [__Optional__]" .. name .. (opt.desc and (" - " .. opt.desc) or ""))

					opts[name] = nil

					CACHE_TABLE(opt)
				end
			end

			-- Scan properties
			local props = GetProperties(ns)
			local hasPropertyHeader = false

			if props and next(props) then
				tinsert(rs, "  Property :")
				hasPropertyHeader = true

				for _, name in ipairs(props) do
					local desc = getDescription(ns, name, AttributeTargets.Property)
					local isOptional = IsOptionalMethod(ns, name)
					local isRequire = IsRequiredMethod(ns, name)

					if opts[name] then isOptional = true; desc = desc or opts[name].desc end
					if reqs[name] then isRequire = true; desc = desc or reqs[name].desc end

					tinsert(rs, "    " .. (isOptional and "[__Optional__]" or "") ..
											(isRequire and "[__Require__]" or "") ..
											name ..
											(desc and (" - " .. desc) or ""))

					if opts[name] then CACHE_TABLE(opts[name]); opts[name] = nil end
					if reqs[name] then CACHE_TABLE(reqs[name]); reqs[name] = nil end
				end
			end

			for name, req in pairs(reqs) do
				if req.type == "property" then
					if not hasPropertyHeader then
						tinsert(rs, "  Property :")
						hasPropertyHeader = true
					end

					tinsert(rs, "    [__Require__]" .. name .. (req.desc and (" - " .. req.desc) or ""))

					reqs[name] = nil

					CACHE_TABLE(req)
				end
			end

			for name, opt in pairs(opts) do
				if opt.type == "method" then
					if not hasPropertyHeader then
						tinsert(rs, "  Property :")
						hasPropertyHeader = true
					end

					tinsert(rs, "    [__Optional__]" .. name .. (opt.desc and (" - " .. opt.desc) or ""))

					opts[name] = nil

					CACHE_TABLE(opt)
				end
			end

			-- Recycle
			for name, req in pairs(reqs) do reqs[name] = nil; CACHE_TABLE(req) end CACHE_TABLE(reqs)
			for name, opt in pairs(opts) do opts[name] = nil; CACHE_TABLE(opt) end CACHE_TABLE(opts)

			-- Scan constructors
			if IsClass(ns) then

			end
		else
		end



		if ns and _NSInfo[ns] then
			local info = _NSInfo[ns]

			if info.Type == TYPE_INTERFACE or info.Type == TYPE_CLASS then
				-- Interface & Class
				if type(targetType) ~= "string" then
					-- Constructor
					local isFormat = false

					if info.Type == TYPE_CLASS then
						-- Check FixedMethod
						local sinfo = info

						while not sinfo.Constructor and sinfo.SuperClass do
							sinfo = _NSInfo[sinfo.SuperClass]
						end

						if getmetatable(sinfo.Constructor) then
							result = result .. "\n\n Fixed Constructor : "

							local cache = CACHE_TABLE()
							local owner = sinfo.Owner
							local ctor = sinfo.Constructor

							while getmetatable(ctor) do
								if ctor.Owner == owner then
									tinsert(cache, ctor)
								else
									local isEqual = false

									for _, ex in ipairs(cache) do
										if #ex == #ctor then
											isEqual = true

											for i = 1, #ctor do
												if not IsEqual(ex[i], ctor[i]) then
													isEqual = false
													break
												end
											end

											if isEqual then break end
										end
									end

									if not isEqual then
										tinsert(cache, ctor)
									end
								end

								ctor = ctor.Next
							end

							for _, ctor in ipairs(cache) do
								local usage = ctor.Usage:match("Usage : (.*)$")

								result = result .. "\n    " .. usage
							end

							CACHE_TABLE(cache)
						end

						while ns do
							isFormat = true

							desc = nil

							if HasPartDocument(ns, "class", GetNameSpaceName(ns)) then
								desc = GetPartDocument(ns, "class", GetNameSpaceName(ns), "format")
								if not desc then
									desc = GetPartDocument(ns, "class", GetNameSpaceName(ns), "param")
									isFormat = false
								end
							elseif HasPartDocument(ns, "default", GetNameSpaceName(ns)) then
								desc = GetPartDocument(ns, "default", GetNameSpaceName(ns), "desc")
								if not desc then
									desc = GetPartDocument(ns, "default", GetNameSpaceName(ns), "param")
									isFormat = false
								end
							end

							if desc then
								-- Constructor
								result = result .. "\n\n  Constructor :"
								if isFormat then
									for fmt in desc do
										result = result .. "\n    " .. GetNameSpaceName(ns) .. "(" .. fmt .. ")"
									end
								else
									result = result .. "\n    " .. GetNameSpaceName(ns) .. "("

									local isFirst = true

									for param in desc do
										if isFirst then
											isFirst = false
											result = result .. param
										else
											result = result .. ", " .. param
										end
									end

									result = result .. ")"
								end

								-- Params
								desc = GetPartDocument(ns, "class", GetNameSpaceName(ns), "param") or GetPartDocument(ns, "default", GetNameSpaceName(ns), "param")
								if desc then
									result = result .. "\n\n  Parameter :"
									for param, info in desc do
										if info and info:len() > 0 then
											result = result .. "\n    " .. param .. " - " .. info
										else
											result = result .. "\n    " .. param
										end
									end
								end

								break
							end

							ns = GetSuperClass(ns)
						end
					end

					return result
				else
					local result
					local querytype

					if info.Type == TYPE_INTERFACE then
						result = "[Interface] " .. GetNameSpaceFullName(ns) .. " - "
					else
						result = "[Class] " .. GetNameSpaceFullName(ns) .. " - "
					end

					if type(name) ~= "string" then
						targetType, name = nil, targetType
					end

					querytype = targetType

					if not querytype then
						if HasEvent(ns, name) then
							querytype = "event"
						elseif HasProperty(ns, name) then
							querytype = "property"
						elseif type(ns[name]) == "function" then
							querytype = "method"
						else
							return
						end
					end

					targetType = querytype or "default"

					if targetType:match("^%a") then
						result = result .. "[" .. strupper(targetType:match("^%a")) .. targetType:sub(2, -1) .. "] " .. name .. " :"
					else
						result = result .. "[" .. targetType .. "] " .. name .. " :"
					end

					local hasDocument = HasPartDocument(ns, targetType, name)

					-- Desc
					local desc = hasDocument and GetPartDocument(ns, targetType, name, "desc")
					desc = desc and desc()
					if desc then
						result = result .. "\n\n  Description :\n    " .. desc:gsub("<br>", "\n    ")
					end

					if querytype == "event" then
						-- __Thread__
						if IsThreadActivated(ns, name) then
							result = result .. "\n\n  [__Thread__]"
						end

						-- Format
						desc = hasDocument and GetPartDocument(ns, targetType, name, "format")
						if desc then
							result = result .. "\n\n  Format :"
							for fmt in desc do
								result = result .. "\n    " .. "function object:" .. name .. "(" .. fmt .. ")\n        -- Handle the event\n    end"
							end
						else
							result = result .. "\n\n  Format :\n    function object:" .. name .. "("

							desc = hasDocument and GetPartDocument(ns, targetType, name, "param")

							if desc then
								local isFirst = true

								for param in desc do
									if isFirst then
										isFirst = false
										result = result .. param
									else
										result = result .. ", " .. param
									end
								end
							end

							result = result .. ")\n        -- Handle the event\n    end"
						end

						-- Params
						desc = hasDocument and GetPartDocument(ns, targetType, name, "param")
						if desc then
							result = result .. "\n\n  Parameter :"
							for param, info in desc do
								if info and info:len() > 0 then
									result = result .. "\n    " .. param .. " - " .. info
								else
									result = result .. "\n    " .. param
								end
							end
						end
					elseif querytype == "property" then
						local types = GetPropertyType(ns, name)

						if types then
							result = result .. "\n\n  Type :\n    " .. tostring(types)
						end

						-- Readonly
						result = result .. "\n\n  Readable :\n    " .. tostring(IsPropertyReadable(ns, name))

						-- Writable
						result = result .. "\n\n  Writable :\n    " .. tostring(IsPropertyWritable(ns, name))
					elseif querytype == "method" then
						local isGlobal = false

						if name:match("^_") then
							isGlobal = true
						else
							if info.Type == TYPE_INTERFACE and info.NonInheritable then
								isGlobal = true
							end
						end

						-- Fixed Method
						local sinfo = info
						local func = info.Cache4Method[name] or info.Method[name]

						while sinfo and not sinfo.Method[name] do
							if sinfo.SuperClass and _NSInfo[sinfo.SuperClass].Cache4Method[name] == func then
								sinfo = _NSInfo[sinfo.SuperClass]
							elseif sinfo.ExtendInterface then
								for _, IF in ipairs(info.ExtendInterface) do
									if _NSInfo[IF].Cache4Method[name] == func then
										sinfo = _NSInfo[IF]
										break
									end
								end
							else
								break
							end
						end

						if sinfo and sinfo.Method[name] and getmetatable(sinfo.Method["0" .. name]) then
							local fm = sinfo.Method["0" .. name]

							result = result .. "\n\n Overload Format : "

							local cache = CACHE_TABLE()
							local owner = sinfo.Owner

							while getmetatable(fm) do
								if fm.Owner == owner then
									tinsert(cache, fm)
								else
									local isEqual = false

									for _, ex in ipairs(cache) do
										if #ex == #fm then
											isEqual = true

											for i = 1, #fm do
												if not IsEqual(ex[i], fm[i]) then
													isEqual = false
													break
												end
											end

											if isEqual then break end
										end
									end

									if not isEqual then
										tinsert(cache, fm)
									end
								end

								fm = fm.Next
							end

							for _, fm in ipairs(cache) do
								local usage = fm.Usage:match("Usage : (.*)$")

								result = result .. "\n    " .. usage
							end

							CACHE_TABLE(cache)
						end

						-- Format
						desc = hasDocument and GetPartDocument(ns, targetType, name, "format")
						result = result .. "\n\n  Format :"
						if desc then
							for fmt in desc do
								if isGlobal then
									result = result .. "\n    " .. GetNameSpaceName(ns) .. "." .. name .. "(" .. fmt .. ")"
								else
									result = result .. "\n    object:" .. name .. "(" .. fmt .. ")"
								end
							end
						else
							if isGlobal then
								result = result .. "\n    " .. GetNameSpaceName(ns) .. "." .. name .. "("
							else
								result = result .. "\n    object:" .. name .. "("
							end

							desc = hasDocument and GetPartDocument(ns, targetType, name, "param")

							if desc then
								local isFirst = true

								for param in desc do
									if isFirst then
										isFirst = false
										result = result .. param
									else
										result = result .. ", " .. param
									end
								end
							end

							result = result .. ")"
						end

						-- Params
						desc = hasDocument and GetPartDocument(ns, targetType, name, "param")
						if desc then
							result = result .. "\n\n  Parameter :"
							for param, info in desc do
								if info and info:len() > 0 then
									result = result .. "\n    " .. param .. " - " .. info
								else
									result = result .. "\n    " .. param
								end
							end
						end

						-- ReturnFormat
						desc = hasDocument and GetPartDocument(ns, targetType, name, "returnformat")
						if desc then
							result = result .. "\n\n  Return Format :"
							for fmt in desc do
								result = result .. "\n    " .. fmt
							end
						end

						-- Returns
						desc = hasDocument and GetPartDocument(ns, targetType, name, "return")
						if desc then
							result = result .. "\n\n  Return :"
							for ret, info in desc do
								if info and info:len() > 0 then
									result = result .. "\n    " .. ret .. " - " .. info
								else
									result = result .. "\n    " .. ret
								end
							end
						end
					else
						-- skip
					end

					-- Usage
					desc = hasDocument and GetPartDocument(ns, targetType, name, "usage")
					if desc then
						result = result .. "\n\n  Usage :"
						for usage in desc do
							result = result .. "\n    " .. usage:gsub("<br>", "\n    ")
						end
					end

					return result
				end
			else
				local result = "[NameSpace] " .. GetNameSpaceFullName(ns) .. " :"
				local desc

				if HasPartDocument(ns, "namespace", GetNameSpaceName(ns)) then
					desc = GetPartDocument(ns, "namespace", GetNameSpaceName(ns), "desc")
				elseif HasPartDocument(ns, "default", GetNameSpaceName(ns)) then
					desc = GetPartDocument(ns, "default", GetNameSpaceName(ns), "desc")
				end

				-- Desc
				desc = desc and desc()
				if desc then
					result = result .. "\n\n  Description :\n    " .. desc
				end

				-- SubNameSpace
				result = result .. buildSubNamespace(ns)

				return result
			end
		end
	end
end)